<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>カラオケプレイヤー - 歌詞全文スクロール</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: "Hiragino Sans", "Yu Gothic UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }
    h1 { font-size: 1.25rem; margin: 0 0 16px; color: #a0a0ff; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }
    input[type="file"] { display: none; }
    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      background: #4a4a6a;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    .btn:hover { background: #5a5a7a; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #6366f1; }
    .btn-primary:hover { background: #818cf8; }
    select {
      padding: 8px 12px;
      border-radius: 6px;
      background: #2d2d44;
      color: #eee;
      border: 1px solid #4a4a6a;
      min-width: 200px;
    }
    .now-playing { margin-bottom: 12px; color: #888; font-size: 14px; }
    .lyrics-wrap {
      background: #16213e;
      border-radius: 12px;
      padding: 20px;
      max-height: 60vh;
      overflow-y: auto;
      margin-bottom: 16px;
      line-height: 1.8;
    }
    .lyrics-wrap::-webkit-scrollbar { width: 8px; }
    .lyrics-wrap::-webkit-scrollbar-track { background: #0f0f1a; border-radius: 4px; }
    .lyrics-wrap::-webkit-scrollbar-thumb { background: #4a4a6a; border-radius: 4px; }
    .lyrics-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 4px 8px;
      border-radius: 6px;
      transition: background 0.2s, color 0.2s;
    }
    .lyrics-line-text { flex: 1; min-width: 0; }
    .lyrics-time {
      flex-shrink: 0;
      font-variant-numeric: tabular-nums;
      color: #888;
      font-size: 13px;
    }
    .lyrics-line.current {
      background: #6366f1;
      color: #fff;
    }
    .lyrics-line.past { color: #666; }
    .lyrics-line.editing-current {
      outline: 1px solid #818cf8;
      background: #1f2937;
    }
    audio {
      width: 100%;
      margin-top: 8px;
    }
    .hint { font-size: 12px; color: #666; margin-top: 8px; }
    .divider { color: #555; margin: 0 4px; }
    .folder-name { margin-left: 12px; color: #888; font-size: 14px; }
    .time-edit {
      margin-top: 12px;
      font-size: 13px;
    }
    .time-edit textarea {
      width: 100%;
      min-height: 120px;
      margin-top: 8px;
      background: #0f172a;
      color: #eee;
      border-radius: 8px;
      border: 1px solid #4a4a6a;
      padding: 8px;
      resize: vertical;
    }
  </style>
</head>
<body>
  <h1>カラオケプレイヤー</h1>
  <div class="controls">
    <button type="button" class="btn btn-primary" id="openFolder">フォルダ選択(MP3/LRC)</button>
    <input type="file" id="folderInput" webkitdirectory directory multiple>
    <select id="songList" disabled>
      <option value="">-- フォルダ選択後に曲を選択 --</option>
    </select>
    <span id="folderName" class="folder-name"></span>
  </div>
  <div class="now-playing" id="nowPlaying"></div>
  <div class="lyrics-wrap" id="lyricsWrap">
    <div id="lyricsInner">「フォルダ選択(MP3/LRC)」でフォルダを選ぶと、フォルダ内の曲一覧から選べます。</div>
  </div>
  <div id="timeEditControls" class="time-edit" style="display:none;">
    <button type="button" class="btn btn-primary" id="markTime">この行に時間を打つ</button>
    <button type="button" class="btn" id="backOneLine">1行戻す</button>
  </div>
  <audio id="audio" controls></audio>
  <p class="hint">例: my-song.mp3 → my-song.lrc（同名でLRCを用意）</p>

  <script>
    const folderInput = document.getElementById('folderInput');
    const folderNameEl = document.getElementById('folderName');
    const songList = document.getElementById('songList');
    const lyricsInner = document.getElementById('lyricsInner');
    const audio = document.getElementById('audio');
    const nowPlaying = document.getElementById('nowPlaying');
    const timeEditControls = document.getElementById('timeEditControls');
    const markTimeBtn = document.getElementById('markTime');
    const backOneLineBtn = document.getElementById('backOneLine');

    let files = []; // フォルダ用: { name, mp3File, lrcFile }
    let enableSync = true; // 時間タグ付き歌詞のときだけ同期スクロールする
    let isTimingMode = false;
    let plainLyricsLines = [];
    let editableLineIndexes = [];
    let currentEditPos = 0;
    let timingMsByLineIndex = [];

    document.getElementById('openFolder').onclick = () => folderInput.click();

    folderInput.addEventListener('change', (e) => {
      const list = Array.from(e.target.files || []);
      const folderName = list.length > 0 && list[0].webkitRelativePath
        ? list[0].webkitRelativePath.split('/')[0]
        : '';
      folderNameEl.textContent = folderName ? 'フォルダ: ' + folderName : '';

      const mp3s = list.filter(f => /\.mp3$/i.test(f.name));
      const lrcMap = {};
      list.filter(f => /\.lrc$/i.test(f.name)).forEach(f => {
        const base = f.name.replace(/\.lrc$/i, '');
        lrcMap[base.toLowerCase()] = f;
      });

      files = mp3s.map(f => {
        const base = f.name.replace(/\.mp3$/i, '');
        return {
          name: base,
          mp3File: f,
          lrcFile: lrcMap[base.toLowerCase()] || null
        };
      });

      songList.innerHTML = '<option value="">-- 曲を選択 --</option>';
      files.forEach((f, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = f.name;
        songList.appendChild(opt);
      });
      songList.disabled = false;
    });

    songList.addEventListener('change', () => {
      const i = parseInt(songList.value, 10);
      if (isNaN(i) || !files[i]) return;
      const item = files[i];
      audio.src = URL.createObjectURL(item.mp3File);
      nowPlaying.textContent = '再生中: ' + item.name;
      resetTimeEdit();
      if (item.lrcFile) {
        item.lrcFile.text().then(text => {
          const hasTimeTag = /^\s*\[\d{1,2}:\d{1,2}(?:[.:]\d{2,3})?\]/m.test(text);
          if (hasTimeTag) {
            const lines = parseLrc(text);
            renderLyrics(lines);
            enableSync = true;
            syncScroll();
          } else {
            enableSync = false;
            renderPlainLyricsFromText(text);
          }
        });
      } else {
        enableSync = false;
        resetTimeEdit();
        lyricsInner.innerHTML = '<p style="color:#888">この曲には .lrc がありません。同名の .lrc を同じフォルダに置いてください。</p>';
      }
    });

    function resetTimeEdit() {
      isTimingMode = false;
      plainLyricsLines = [];
      editableLineIndexes = [];
      currentEditPos = 0;
      timingMsByLineIndex = [];
      if (timeEditControls) timeEditControls.style.display = 'none';
      if (markTimeBtn) markTimeBtn.disabled = true;
      if (backOneLineBtn) backOneLineBtn.disabled = true;
      const linesEls = lyricsInner.querySelectorAll('.lyrics-line');
      linesEls.forEach(el => el.classList.remove('editing-current'));
    }

    function renderPlainLyricsFromText(text) {
      plainLyricsLines = text.split(/\r?\n/);
      editableLineIndexes = [];
      timingMsByLineIndex = new Array(plainLyricsLines.length).fill(null);
      const html = plainLyricsLines.map((line, idx) => {
        if (line.trim() !== '') {
          editableLineIndexes.push(idx);
        }
        return `<div class="lyrics-line" data-line-index="${idx}"><span class="lyrics-line-text">${escapeHtml(line) || '&nbsp;'}</span><span class="lyrics-time" data-line-index="${idx}"></span></div>`;
      }).join('');
      lyricsInner.innerHTML = html;
      if (editableLineIndexes.length > 0) {
        timeEditControls.style.display = 'block';
        isTimingMode = true;
        currentEditPos = -1;
        markTimeBtn.disabled = false;
        backOneLineBtn.disabled = true;
        // -1 = まだどの行も選択していない。1回目のクリックで1行目をハイライト、2回目で1行目に時間を打って2行目へ
      } else {
        timeEditControls.style.display = 'none';
        isTimingMode = false;
        markTimeBtn.disabled = true;
      }
    }

    function parseLrc(text) {
      const lines = [];
      const re = /^\[(\d{1,2}):(\d{1,2})(?:[.:](\d{2,3}))?\](.*)$/;
      text.split(/\r?\n/).forEach(line => {
        const m = line.trim().match(re);
        if (m) {
          const min = parseInt(m[1], 10);
          const sec = parseInt(m[2], 10);
          const cent = parseInt(m[3] || '0', 10);
          const ms = (min * 60 + sec) * 1000 + (cent <= 99 ? cent * 10 : cent);
          lines.push({ time: ms, text: m[4].trim() });
        }
      });
      lines.sort((a, b) => a.time - b.time);
      return lines;
    }

    function renderLyrics(lines) {
      lyricsInner.innerHTML = lines.map((line, i) =>
        `<div class="lyrics-line" data-time="${line.time}" data-index="${i}">${escapeHtml(line.text) || '&nbsp;'}</div>`
      ).join('');
    }

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }

    audio.addEventListener('timeupdate', syncScroll);

    function syncScroll() {
      if (!enableSync) return;
      const t = audio.currentTime * 1000;
      const lines = lyricsInner.querySelectorAll('.lyrics-line');
      lines.forEach(el => el.classList.remove('current', 'past'));
      let current = null;
      for (let i = lines.length - 1; i >= 0; i--) {
        const time = parseInt(lines[i].dataset.time, 10);
        if (time <= t) {
          current = lines[i];
          for (let j = 0; j < i; j++) lines[j].classList.add('past');
          break;
        }
      }
      if (current) {
        current.classList.add('current');
        current.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function setCurrentEditHighlight() {
      const linesEls = lyricsInner.querySelectorAll('.lyrics-line');
      linesEls.forEach(el => el.classList.remove('editing-current'));
      if (!isTimingMode || currentEditPos < 0 || currentEditPos >= editableLineIndexes.length) return;
      const lineIndex = editableLineIndexes[currentEditPos];
      const target = lyricsInner.querySelector(`.lyrics-line[data-line-index="${lineIndex}"]`);
      if (target) {
        target.classList.add('editing-current');
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function formatTimeTag(ms) {
      const totalMs = Math.max(0, Math.floor(ms));
      const totalSec = Math.floor(totalMs / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      const cent = Math.floor((totalMs % 1000) / 10);
      const mm = String(min).padStart(2, '0');
      const ss = String(sec).padStart(2, '0');
      const cc = String(cent).padStart(2, '0');
      return `[${mm}:${ss}.${cc}]`;
    }

    function formatTimeDisplay(ms) {
      const totalMs = Math.max(0, Math.floor(ms));
      const totalSec = Math.floor(totalMs / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      const cent = Math.floor((totalMs % 1000) / 10);
      return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}.${String(cent).padStart(2, '0')}`;
    }

    function setLineTimeDisplay(lineIndex, ms) {
      const el = lyricsInner.querySelector(`.lyrics-time[data-line-index="${lineIndex}"]`);
      if (el) el.textContent = ms != null ? formatTimeDisplay(ms) : '';
    }

    function buildLrcFromTiming() {
      if (!plainLyricsLines.length) return '';
      return plainLyricsLines.map((line, idx) => {
        const text = line;
        if (text.trim() === '') return '';
        const ms = timingMsByLineIndex[idx];
        if (ms == null) return text;
        return formatTimeTag(ms) + text;
      }).join('\n');
    }

    markTimeBtn.addEventListener('click', () => {
      if (!isTimingMode) return;
      if (currentEditPos === -1) {
        currentEditPos = 0;
        backOneLineBtn.disabled = false;
        const lineIndex = editableLineIndexes[0];
        const ms = Math.floor(audio.currentTime * 1000);
        timingMsByLineIndex[lineIndex] = ms;
        setLineTimeDisplay(lineIndex, ms);
        setCurrentEditHighlight();
        return;
      }
      if (currentEditPos >= editableLineIndexes.length) return;
      const ms = Math.floor(audio.currentTime * 1000);
      const isLastLine = (currentEditPos === editableLineIndexes.length - 1);
      if (isLastLine) {
        const lineIndex = editableLineIndexes[currentEditPos];
        timingMsByLineIndex[lineIndex] = ms;
        setLineTimeDisplay(lineIndex, ms);
        currentEditPos++;
        const linesEls = lyricsInner.querySelectorAll('.lyrics-line');
        linesEls.forEach(el => el.classList.remove('editing-current'));
        markTimeBtn.disabled = true;
      } else {
        currentEditPos++;
        const lineIndex = editableLineIndexes[currentEditPos];
        timingMsByLineIndex[lineIndex] = ms;
        setLineTimeDisplay(lineIndex, ms);
        setCurrentEditHighlight();
      }
    });

    backOneLineBtn.addEventListener('click', () => {
      if (!isTimingMode) return;
      if (currentEditPos === -1) return;
      if (currentEditPos >= editableLineIndexes.length) {
        currentEditPos = editableLineIndexes.length - 1;
        const lineIndex = editableLineIndexes[currentEditPos];
        timingMsByLineIndex[lineIndex] = null;
        setLineTimeDisplay(lineIndex, null);
        setCurrentEditHighlight();
        markTimeBtn.disabled = false;
        return;
      }
      const lineIndexToClear = editableLineIndexes[currentEditPos];
      timingMsByLineIndex[lineIndexToClear] = null;
      setLineTimeDisplay(lineIndexToClear, null);
      currentEditPos--;
      if (currentEditPos === -1) {
        const linesEls = lyricsInner.querySelectorAll('.lyrics-line');
        linesEls.forEach(el => el.classList.remove('editing-current'));
        backOneLineBtn.disabled = true;
      } else {
        setCurrentEditHighlight();
      }
    });
  </script>
</body>
</html>
